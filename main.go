// bakego bakes files' data into a go file.
package main

import (
	"bufio"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

// readFile reads a file.
func readFile(f string) string {
	b, err := ioutil.ReadFile(f)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	return string(b)
}

// die exits this program with error message.
func die(e string) {
	fmt.Fprintln(os.Stderr, e)
	os.Exit(1)
}

// trimExt trims ext from file name.
func trimExt(f string) string {
	return f[:len(f)-len(filepath.Ext(f))]
}

// filePackage finds package name from existing go files.
func findPackage() string {
	files, err := filepath.Glob("*.go")
	if err != nil {
		die(err.Error())
	}
	pkg := ""
	for _, f := range files {
		if strings.HasPrefix(f, "gen_bakego_") || strings.HasSuffix(trimExt(f), "_test") {
			continue
		}
		text := readFile(f)
		lines := strings.Split(text, "\n")
		for _, line := range lines {
			line = strings.TrimSpace(line)
			if strings.HasPrefix(line, "package ") {
				words := strings.Fields(line)
				if words[1] != "" {
					pkg = words[1]
					break
				}
			}
		}
	}
	if pkg == "" {
		fmt.Fprintln(os.Stderr, "could not find package name from go file")
		os.Exit(1)
	}
	return pkg
}

// genGo generates a go file from input files.
func genGo(files map[string]string, pkg string) {
	f, err := os.Create("gen_bakego.go")
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	defer f.Close()
	w := bufio.NewWriter(f)
	defer w.Flush()

	w.WriteString("// Code generated by github.com/kybin/bakego. DO NOT EDIT.\n")
	w.WriteString(fmt.Sprintf("package %s\n\n", pkg))
	w.WriteString(`import (
	"bufio"
	"path/filepath"
	"os"
)`)
	w.WriteString("\n\n")
	w.WriteString(`type BakeGo struct {
	files map[string][]byte
}`)
	w.WriteString("\n\n")
	w.WriteString(`func (b *BakeGo) Extract() error {
	for fname, data := range b.files {
		err := os.MkdirAll(filepath.Dir(fname), 0644)
		if err != nil {
			return err
		}
		f, err := os.Create(fname)
		if err != nil {
			return err
		}
		w := bufio.NewWriter(f)
		_, err = w.Write(data)
		if err != nil {
			return err
		}
		w.Flush()
	}
	return nil
}`)
	w.WriteString("\n\n")
	w.WriteString("var bakego = &BakeGo{}\n\n")
	w.WriteString("func init() {\n")
	w.WriteString("\tbakego.files = make(map[string][]byte)\n\n")
	for f, bs := range files {
		w.WriteString(fmt.Sprintf("\tbakego.files[\"%s\"] = []byte(", f))
		// cannot handle ` inside of raw string
		// make them as separate strings
		s := string(bs)
		s = strings.Replace(s, "`", "` + \"`\" + `", -1)
		s = "`" + s + "`"
		w.WriteString(s)
		w.WriteString(")\n")
	}
	w.WriteString("}\n")
}

func main() {
	var (
		recursive bool
		dir       bool
	)
	flag.BoolVar(&dir, "d", false, "add files inside of the directory")
	flag.BoolVar(&recursive, "r", false, "add files inside of the directory recursively")
	flag.Parse()
	elems := flag.Args()
	if len(elems) == 0 {
		fmt.Fprintln(os.Stderr, "ex) bakego [args...] [file|dir...]")
		os.Exit(1)
	}
	files := make(map[string]string)
	for _, el := range elems {
		fi, err := os.Stat(el)
		if err != nil {
			fmt.Fprint(os.Stderr, err)
			os.Exit(1)
		}
		if fi.IsDir() {
			if !dir && !recursive {
				fmt.Fprintln(os.Stderr, "if you want to add a directory, use -d or -r flag")
				os.Exit(1)
			}
			d := len(filepath.SplitList(el))
			filepath.Walk(el, func(path string, info os.FileInfo, err error) error {
				if err != nil {
					return err
				}
				if info.IsDir() {
					if recursive {
						return nil
					}
					wd := len(filepath.SplitList(path))
					if wd-d <= 1 {
						return nil
					}
					return filepath.SkipDir
				}
				files[path] = readFile(path)
				return nil
			})
		} else {
			files[el] = readFile(el)
		}
	}
	pkg := findPackage()
	genGo(files, pkg)
}
