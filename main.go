// bakego bakes files' data into a go file.
package main

import (
	"bufio"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

// readFile reads a file.
func readFile(f string) string {
	b, err := ioutil.ReadFile(f)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	return string(b)
}

// die exits this program with error message.
func die(e string) {
	fmt.Fprintln(os.Stderr, e)
	os.Exit(1)
}

// trimExt trims ext from file name.
func trimExt(f string) string {
	return f[:len(f)-len(filepath.Ext(f))]
}

// filePackage finds package name from existing go files.
func findPackage() string {
	files, err := filepath.Glob("*.go")
	if err != nil {
		die(err.Error())
	}
	pkg := ""
	for _, f := range files {
		if strings.HasPrefix(f, "gen_bakego_") || strings.HasSuffix(trimExt(f), "_test") {
			continue
		}
		text := readFile(f)
		lines := strings.Split(text, "\n")
		for _, line := range lines {
			line = strings.TrimSpace(line)
			if strings.HasPrefix(line, "package ") {
				words := strings.Fields(line)
				if words[1] != "" {
					pkg = words[1]
					break
				}
			}
		}
	}
	if pkg == "" {
		fmt.Fprintln(os.Stderr, "could not find package name from go file")
		os.Exit(1)
	}
	return pkg
}

// genGo generates a go file from input files.
func genGo(files map[string]string, pkg, destvar string) {
	f, err := os.Create("gen_bakego_" + destvar + ".go")
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	defer f.Close()
	w := bufio.NewWriter(f)
	defer w.Flush()
	w.WriteString("// Code generated by github.com/kybin/bakego. DO NOT EDIT.\n")
	w.WriteString(fmt.Sprintf("package %s\n\n", pkg))
	w.WriteString(fmt.Sprintf("var %s = make(map[string][]byte)\n\n", destvar))
	w.WriteString("func init() {\n")
	for f, bs := range files {
		w.WriteString(fmt.Sprintf("\t%s[\"%s\"] = []byte(", destvar, f))
		// cannot handle ` inside of raw string
		// make them as separate strings
		s := string(bs)
		s = strings.Replace(s, "`", "` + \"`\" + `", -1)
		s = "`" + s + "`"
		w.WriteString(s)
		w.WriteString(")\n")
	}
	w.WriteString("}\n")
}

func main() {
	var (
		recursive bool
		dir       bool
	)
	flag.BoolVar(&dir, "d", false, "add files inside of the directory")
	flag.BoolVar(&recursive, "r", false, "add files inside of the directory recursively")
	flag.Parse()
	args := flag.Args()
	if len(args) != 2 {
		fmt.Fprintln(os.Stderr, "ex) bakego [args...] [file|dir] [destvar]")
		os.Exit(1)
	}
	el := args[0]
	destvar := args[1]
	fi, err := os.Stat(el)
	if err != nil {
		fmt.Fprint(os.Stderr, err)
		os.Exit(1)
	}
	pkg := findPackage()
	files := make(map[string]string)
	if fi.IsDir() {
		if !dir && !recursive {
			fmt.Fprintln(os.Stderr, "if you want to add a directory, use -d or -r flag")
			os.Exit(1)
		}
		d := len(filepath.SplitList(el))
		filepath.Walk(el, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if info.IsDir() {
				if recursive {
					return nil
				}
				wd := len(filepath.SplitList(path))
				if wd-d <= 1 {
					return nil
				}
				return filepath.SkipDir
			}
			files[path] = readFile(path)
			return nil
		})
	} else {
		files[el] = readFile(el)
	}
	genGo(files, pkg, destvar)
}
