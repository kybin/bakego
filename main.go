// bakego bakes files' data into a go file.
package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// readFile reads a file.
func readFile(f string) []byte {
	b, err := ioutil.ReadFile(f)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	return b
}

// die exits this program with error message.
func die(e string) {
	fmt.Fprintln(os.Stderr, e)
	os.Exit(1)
}

// trimExt trims ext from file name.
func trimExt(f string) string {
	return f[:len(f)-len(filepath.Ext(f))]
}

// filePackage finds package name from existing go files.
func findPackage() string {
	files, err := filepath.Glob("*.go")
	if err != nil {
		die(err.Error())
	}
	pkg := ""
	for _, f := range files {
		if strings.HasPrefix(f, "gen_bakego_") || strings.HasSuffix(trimExt(f), "_test") {
			continue
		}
		text := readFile(f)
		lines := bytes.Split(text, []byte("\n"))
		for _, line := range lines {
			line = bytes.TrimSpace(line)
			if bytes.HasPrefix(line, []byte("package ")) {
				words := bytes.Fields(line)
				if string(words[1]) != "" {
					pkg = string(words[1])
					break
				}
			}
		}
	}
	if pkg == "" {
		fmt.Fprintln(os.Stderr, "could not find package name from go file")
		os.Exit(1)
	}
	return pkg
}

// genGo generates a go file from input files.
func genGo(files []File, pkg string) {
	f, err := os.Create("gen_bakego.go")
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	defer f.Close()
	w := bufio.NewWriter(f)
	defer w.Flush()

	w.WriteString("// Code generated by github.com/kybin/bakego. DO NOT EDIT.\n")
	w.WriteString(fmt.Sprintf("package %s\n", pkg))
	w.WriteString(`
import (
	"bufio"
	"os"
	"path/filepath"
)

type BakeGoFile struct {
	fname string
	data []byte
}

type BakeGo []BakeGoFile

// Extract extracts all remebered files.
func (b BakeGo) Extract() error {
	for _, s := range b {
		fname := s.fname
		data := s.data
		err := os.MkdirAll(filepath.Dir(fname), 0644)
		if err != nil {
			return err
		}
		f, err := os.Create(fname)
		if err != nil {
			return err
		}
		w := bufio.NewWriter(f)
		_, err = w.Write(data)
		if err != nil {
			return err
		}
		w.Flush()
	}
	return nil
}

// Ensure checks all the BakeGo files are exist.
// It will return nil if all files are exist or return error.
//
// It does not check the files are modified or not.
func (b BakeGo) Ensure() error {
	for _, s := range b {
		_, err := os.Stat(s.fname)
		if err != nil {
			return err
		}
	}
	return nil
}

var bakego BakeGo = make([]BakeGoFile, 0)

func init() {
`)
	sort.Slice(files, func(i, j int) bool {
		return files[i].fname < files[j].fname
	})
	for _, s := range files {
		f := s.fname
		bs := s.data
		w.WriteString(fmt.Sprintf("\tbakego = append(bakego, BakeGoFile{\"%s\", []byte(", f))
		// cannot handle ` inside of raw string
		// make them as separate strings
		s := string(bs)
		s = strings.Replace(s, "`", "` + \"`\" + `", -1)
		s = "`" + s + "`"
		w.WriteString(s)
		w.WriteString(")})\n")
	}
	w.WriteString("}\n")
}

type File struct {
	fname string
	data  []byte
}

func main() {
	var (
		recursive bool
		dir       bool
	)
	flag.BoolVar(&dir, "d", false, "add files inside of the directory")
	flag.BoolVar(&recursive, "r", false, "add files inside of the directory recursively")
	flag.Parse()
	elems := flag.Args()
	if len(elems) == 0 {
		fmt.Fprintln(os.Stderr, "ex) bakego [args...] [file|dir...]")
		os.Exit(1)
	}
	files := make([]File, 0)
	for _, el := range elems {
		fi, err := os.Stat(el)
		if err != nil {
			fmt.Fprint(os.Stderr, err)
			os.Exit(1)
		}
		if fi.IsDir() {
			if !dir && !recursive {
				fmt.Fprintln(os.Stderr, "if you want to add a directory, use -d or -r flag")
				os.Exit(1)
			}
			d := len(filepath.SplitList(el))
			filepath.Walk(el, func(path string, info os.FileInfo, err error) error {
				if err != nil {
					return err
				}
				if info.IsDir() {
					if recursive {
						return nil
					}
					wd := len(filepath.SplitList(path))
					if wd-d <= 1 {
						return nil
					}
					return filepath.SkipDir
				}
				files = append(files, File{path, readFile(path)})
				return nil
			})
		} else {
			files = append(files, File{el, readFile(el)})
		}
	}
	pkg := findPackage()
	genGo(files, pkg)
}
